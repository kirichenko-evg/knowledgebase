## CBV vs FBV
Class-Based Views
| Плюсы | Минусы |
|---|---|
| Возможность повторного использования кода. В CBV класс представления может быть унаследован другим классом представления и изменен для другого варианта использования | Сложнее в чтении кода |
| DRY использование CBVs помогает уменьшить дублирование кода | Неявный поток кода |
| Возможность расширения кода с помощью миксинов | Использования декораторов требует дополнительной обработки |
| Структурирование кода - CBVs помогает легко обрабатывать разные HTTP-запросы без условного ветвления |   |

Function-Based Views
| Плюсы | Минусы |
|---|---|
| Простота в реализации | Трудно расширить и повторно использовать код |
| Легко читать | Обработка HTTP-запросов с помощью условного ветвления |
| Явный поток кода |   |
| Простое использование декораторов |   |
| Подходит для одноразовой функциональности |   |

В Django встроены некоторые классовые представления
- TemplateView - отвечает за отображение шаблона
- DetailView - отображение конкретного объекта
- ListView - отвечает за отображение всех товаров и другие.

## IndexView
Переводим функцию index() в классовое представление. Правки в `products\views.py`
```python
from django.views.generic.base import TemplateView  # рендерит шаблон и отображает его на странице

class IndexView(TemplateView):
    template_name = 'products/index.html'
```
Переходим в `store\urls.py`. Для отображения контекста (в котором передаем тайтл) можно прописать его прямо здесь, в данном файле.
```python
from products.views import IndexView
urlpatterns = [
    path('', IndexView.as_view(extra_context={'title': 'Store'}), name='index'),
]
```
Но передавать контекст таким образом не всегда удобно. Поэтому дополняем класс IndexView в `products\views.py`
```python
class IndexView(TemplateView):
    template_name = 'products/index.html'

    # получается мы дополняем стандартный метод и добавляем свои данные в контекст
    def get_context_data(self, **kwargs):
        context = super(IndexView, self).get_context_data()
        context['title'] = 'Store'
        return context
```
А в `store\urls.py` изменяем строку `path('', IndexView.as_view(), name='index'),`.

## ProductsListView
В `products/views.py` работаем в классом ProductsListView
```python
from django.views.generic.list import ListView
from products.models import ProductCategory, Product, Basket

class ProductsListView(ListView):
    model = Product
    template_name = 'products/products.html'
    paginate_by = 3  # пагинация есть из коробки

    def get_queryset(self):
        queryset = super(ProductsListView,self).get_queryset()
        # если его нет, т.е. при первой загрузке без выбора категории, то придет None
        category_id = self.kwargs.get('category_id')
        # чистый queryset это аналог Product.objects.all()
        return queryset.filter(category_id=category_id) if category_id else queryset

    def get_context_data(self, *, object_list=None, **kwargs):
        context = super(ProductsListView, self).get_context_data()
        context['title'] = 'Store - Каталог'
        context['categories'] = ProductCategory.objects.all()
        return context
```
Меняем `products/urls.py`
```python
from products.views import ProductsListView, basket_add, basket_remove

urlpatterns = [
    path('', ProductsListView.as_view(), name='index'),
    # фильтрация по категориям меняем тоже
    path('category/<int:category_id>', ProductsListView.as_view(), name='category'),
    # пагинация меняется
    path('page/<int:page>', ProductsListView.as_view(), name='paginator'),
...
```
Но также нужно исправить сам шаблон для отображения товаров `products/templates/products/products.html`. Заменяем там products на object_list, т.к. такое обращение уже заложено в базовом классе. Также делаем пагинацию. Ее отображаем только когда товаров больше 3.
```html
<div class="row">
    {% for product in object_list %}
...
{% if is_paginated %}
<nav aria-label="Page navigation example">
    <ul class="pagination justify-content-center">
        <li class="page-item {% if not page_obj.has_previous %} disabled {% endif %}">
            <a class="page-link" href="{% if page_obj.has_previous %} {% url 'products:paginator' page_obj.previous_page_number %} {% else %} # {% endif %}" tabindex="-1" aria-disabled="true">Предыдущая</a>
        </li>
         {% for page in paginator.page_range %}
         <li class="page-item"><a class="page-link" href="{% url 'products:paginator' page %}">
             {{ page }}
         </a></li>
         {% endfor %}
         <li class="page-item {% if not page_obj.has_next %} disabled {% endif %}">
             <a class="page-link" href="{% if page_obj.has_next %} {% url 'products:paginator' page_obj.next_page_number %} {% else %} # {% endif %}">Следующая</a>
         </li>
     </ul>
</nav>
{% endif %}
```

## UserRegistrationView и UserProfileView

