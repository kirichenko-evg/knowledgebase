## Пространство имен в диспетчере URL
http://127.0.0.1:8000/products/ сейчас такой вид и формируется он из `urls.py`.
```python
urlpatterns = [
    path('products/', products, name='products'),
]
```
Логично сделать файл `urls.py` отдельно для приложения. Т.е. в products, в приложение, перенесем все url, что связаны с products. А в `urls.py` будет следующая конструкция. Также нужно импортировать функцию include
```python
from django.urls import path, include

urlpatterns = [
    path('products/', include('products.urls', namespace='products')),
]
```
Создаем `urls.py` в приложении (директории) `products`. Задаем app_name и имя index.
```python
from django.urls import path
from products.views import products

app_name = 'products'

urlpatterns = [
    path('', products, name='index'),
]

```
В html изменится обращение к данной странице в href
```html
 <a id="start-purchase-link" href="{% url 'products:index' %}">
  Начать покупки
</a>
```

## Клиент-серверная архитектура, GET и POST запросы
Сервер и клиент общаются посредством GET и POST запросов.
- GET - например обычный запрос страницы. Клиент запросил страницу, сервер ее вернул. Возвращает с определенным ответом (response). Коды ответов:
  - информационные 1xx
  - успешные 2xx
  - перенаправления 3xx
  - ошибки клиента 4xx
  - ошибки сервера 5xx
- POST - отправка формы

## Traceback и Debug-режим
Traceback - ошибка при разработке, которая отображается в браузере и в логах PyCharm. В браузере отображается потому что debug=True.

Debug-режим - пройти по шагам для поиска ошибки. Также с дебагером удобно смотреть что содержится внутри объектов и как они изменяются при передаче клиенту.

## Model View Template
MVT - паттерн проектирования.
- template - html, css, form. Пример - форма. Пользователь вводит данные формы и нажимает кнопку отправить.
- view (request, response). Форма попадает в контроллер, данныер проходят валидацию, выполняется какая-то логика
- model - работа с БД. Если это регистрация, авторизация в форме, то создается или изменяется объект в БД.

## Создание собственной модели пользователя
1. Создаем приложение users - `./manage.py startapp users`
2. Перейти в `settings.py` и внести `users` в `INSTALLED_APPS`
3. В структуре `users` переходим в `models.py` и расширяем модель существующего стандартного пользователя.
```python
from django.db import models
from django.contrib.auth.models import AbstractUser

class User(AbstractUser):
    image = models.ImageField(upload_to='users_images', null=True, blank=True)
```
4. Создаем миграцию `./manage.py makemigrations`. Но т.к. планировать структуру нужно заранее, при миграции возникнет ошибка.
5. В файл `settings.py` добавляем блок для users
```python
# users
AUTH_USER_MODEL = 'users.User'
```
6. Удаляем БД и делаем миграции заново, загружаем таблицы из фикстур
7. Для отображения пользователей в админке модель нужно зарегистрировать
```python
from django.contrib import admin
from users.models import User

admin.site.register(User)
```

## Подготовка проекта к работе с пользователями
Для пользователей есть свои html-страницы, поэтому в директории users нужно создать папку templates, а в ней снова users. Делаем base.html, копируем страницы наследуясь от базового класса и т.д. 
```python
{% extends 'users/base.html' %}

{% block content %}
<main>
...
</main>
{% endblock %}
```
В главной urls.py добавляем users
```python
urlpatterns = [
    path('admin/', admin.site.urls),
    path('', index, name='index'),
    path('products/', include('products.urls', namespace='products')),
    path('users/', include('users.urls', namespace='users')),
]
```
Создаем новый urls.py внутри директории users
```python
from django.urls import path
from users.views import login, registration

app_name = 'users'

urlpatterns = [
    path('login/', login, name='login'),
    path('registration/', registration, name='registration'),
]

```

## Формы в Django
В users создаем новый файл `forms.py`. 
```python
# импорт стандартной аутентификации чтобы не создавать заново уже существующий функционал
from django.contrib.auth.forms import AuthenticationForm

# импорт модели пользователей
from users.models import User


class UserLoginForm(AuthenticationForm):
    # класс Meta отвечает за то, с какой моделью будет работать форма и с какими полями
    class Meta:
        model = User
        fields = ('username', 'password')
```
Изменяем файл `views.py`. Импортируем модель, форму, дописываем в login контекст.
```python
from django.shortcuts import render

from users.models import User
from users.forms import UserLoginForm


def login(request):
    context = {'form': UserLoginForm()}
    return render(request, 'users/login.html', context)


def registration(request):
    return render(request, 'users/registration.html')
```
Переходим в `login.html` и временно комментируем поля в форме, связанные с именем и паролем. Взамен делаем отображение формы из файла `forms.py`. С помощью плейсхолдера обращаемся к ключу form, который является экзмпляром класса UserLoginForm. Т.е. это объект и тут есть способы отображения:
- как p теги as_p
- как таблица as_table
- как ul теги as_ul
```html
<div class="card-body">
    <form>
        {{ form.as_p }}
...
```
После этого появятся поля, но без стилей.

## Контроллер авторизации формы
Важно при создании контроллера формы учитывать
- audit - контроль
- authentication - подтверждение подлинности, наличие пользователя в БД
- authorisation - разрешение, не забанен ли пользователь, есть ли права

Для формы работаем с файлом из директории users `views.py`
```python
# импорт редиректа для перенаправления на главную
from django.shortcuts import render, HttpResponseRedirect
# импорт аутентификации
from django.contrib import auth
from django.urls import reverse

from users.models import User
from users.forms import UserLoginForm


def login(request):

    # если форма отправилась
    if request.method == 'POST':
        form = UserLoginForm(data=request.POST)

        # проверка данных на валидность
        if form.is_valid():
            username = request.POST['username']
            password = request.POST['password']

            # найти пользователя
            user = auth.authenticate(username=username, password=password)

            # если пользователь существует
            if user:
                auth.login(request, user)

                # редирект на главную
                # reverse возвращает строку где находится адрес
                return HttpResponseRedirect(reverse('index'))

    # если метод GET, т.е. пользователь просто запросил страницу
    else:
        form = UserLoginForm()
    context = {'form': form}
    return render(request, 'users/login.html', context)
```
Правки в login.html, токен нужен для защиты, также дописываем action и method
```html
 <div class="card-body">
    <form action="{% url 'users:login' %}" method="POST">
        {% csrf_token %}
        {{ form.as_p }}
...
```

## Собственные шаблоны авторизации
Сначала нужно модифицировать файл `forms.py`. В username и password берем класс и плейсхолдер из верстки.
```python
# импорт форм для кастомизации форм
from django import forms
from django.contrib.auth.forms import AuthenticationForm
from users.models import User

class UserLoginForm(AuthenticationForm):
    username = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4',
        'placeholder': 'Введите имя пользователя'
    }))
    password = forms.CharField(widget=forms.PasswordInput(attrs={
        'class': 'form-control py-4',
        'placeholder': 'Введите пароль'
    }))
    class Meta:
        model = User
        fields = ('username', 'password')
```
Исправляем файл с версткой `login.html`. Удаляем вывод формы `{{ form.as_p }}`, вместо инпута указывается {{ form.username }}, в label исправляется атрибут for.
```html
<form action="{% url 'users:login' %}" method="POST">
    {% csrf_token %}
    <div class="form-group">
        <label class="small mb-1" for="{{ form.username.id_for_label }}">Имя пользователя</label>
        {{ form.username }}
    </div>
    <div class="form-group">
         <label class="small mb-1" for="{{ form.password.id_for_label }}">Пароль</label>
         {{ form.password }}
    </div>
...
```

## Форма для регистрации
В `forms.py` создаем еще одну форму для регистрации
```python
from django import forms
from django.contrib.auth.forms import AuthenticationForm, UserCreationForm  # тут импортируем UserCreationForm
from users.models import User

...

class UserRegistrationForm(UserCreationForm):
    firstname = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4',
        'placeholder': 'Введите имя'
    }))
    lastname = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4',
        'placeholder': 'Введите фамилию'
    }))
    username = forms.CharField(widget=forms.TextInput(attrs={
        'class': 'form-control py-4',
        'placeholder': 'Введите имя пользователя'
    }))
    email = forms.CharField(widget=forms.EmailInput(attrs={
        'class': 'form-control py-4',
        'placeholder': 'Введите адрес эл. почты'
    }))
    password1 = forms.CharField(widget=forms.PasswordInput(attrs={
        'class': 'form-control py-4',
        'placeholder': 'Введите пароль'
    }))
    password2 = forms.CharField(widget=forms.PasswordInput(attrs={
        'class': 'form-control py-4',
        'placeholder': 'Подтвердите пароль'
    }))

    class Meta:
        model = User
        # password1 и password2 - введите и подтвердите пароль
        fields = ('firstname', 'lastname', 'username', 'email', 'password1', 'password2')
```
Далее редактируем `views.py`
```python
from django.shortcuts import render, HttpResponseRedirect
from django.contrib import auth
from django.urls import reverse

from users.models import User
from users.forms import UserLoginForm, UserRegistrationForm  # тут добавилась форма

...

def registration(request):
    if request.method == 'POST':
        form = UserRegistrationForm(data=request.POST)
        if form.is_valid():
            form.save()
            return HttpResponseRedirect(reverse('users:login'))
    else:
        form = UserRegistrationForm()
    context = {'form': form}
    return render(request, 'users/registration.html', context)
```
И исправляем `registration.html`
```html
<form action="{% url 'users:registration' %}" method="POST">
    {% csrf_token %}
    <div class="form-row">
        <div class="col-md-6">
            <div class="form-group">
                <label class="small mb-1" for="{{ form.firstname.id_for_label }}">Имя</label>
                {{ form.firstname }}
            </div>
       </div>
...
```
