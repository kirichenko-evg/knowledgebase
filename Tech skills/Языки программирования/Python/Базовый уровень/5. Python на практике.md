## Обрабатываем данные
Форматы данных делятся на текстовые и бинарные. 

Строки в Питоне 3-й версии, как текстовый формат данных,представляют собой последовательность Unicode. Unicode — это действующий международный стандарт, определяющий символы всех языков мира плюс математические и другие символы. Каждый символ юникода имеет уникальное имя и идентификационный номер. Python может работать со всеми этими символами. Они разбиты на восьмибитные наборы, которые называются плоскостями. Первые 256 плоскостей называются основными многоязычными уровнями.

Если известен Unicode ID или название символа, то можно использовать его в строке Python. Например
- Символ \u и расположенные за ним четыре шестнадцатеричных числа определяют символ, находящийся в одной из 256 многоязычных плоскостей Unicode. Два первых числа являются номером плоскости (от 00 до FF), а следующие два — индексом символа внутри плоскости. Плоскость с номером 00 — это с формат ASCII, и позиции символов в нем такие же, как и в ASCII.
- Для символов более высоких плоскостей нужно больше битов. Управляющая последовательность для них выглядит как U: за ней следуют восемь шестнадцатеричных символов, крайний слева из которых должен быть равен 0.
- Для всех символов конструкция \N{имя} позволяет указать символ с помощью его стандартного имени.

Модуль `unicodedata` содержит функции, которые преобразуют символы в обоих направлениях:
- lookup() принимает не зависящее от регистра имя и возвращает символ Unicode;
- name() принимает символ Unicode и возвращает его имя в верхнем регистре.

Не нужно думать о том, как Python хранит каждый символ Unicode, когда выполняется обычная обработка строки. Но когда идет обмен данными с внешним миром, может понадобиться следующее:
- способ закодировать строку в байты;
- способ декодировать байты обратно в строку.
Для этого была разработана UTF-8 - динамеческая схема кодирования. Она использует для символа Unicode от 1 до 4 байт:
- 1 байт для ASCII;
- 2 байта для большинства языков, основанных на латинице (но не кириллице);
- 3 байта для других основных языков;
- 4 байта для остальных языков, включая некоторые азиатские языки и символы.

## Регулярные выражения
Используется стандартный модуль re. `import re`
- re.match('So', 'Some test') - So искомый шаблон в строке 'Some test'. match() проверяет начинается ли источник с шаблона.
- можно скомпиилровать шаблон, чтобы ускорить проверку
```python
import re
youpattern = re.compile('You')
result = youpattern.match('Young Frankenstein')
```
Можно найти первое совпадение с помощью функции match() и в середине строки:
```python
m = re.match('.*Frank', source)
if m: # функция match возвращает объект
  print(m.group())

Young Frank
```
Как работает новый шаблон '.*Frank':
  * символ `.` означает любой отдельный символ;
  * символ `*` означает ноль или более предыдущих элементов. Если объединить символы `.*`, они будут означать любое количество символов (даже ноль);
  * Frank — это фраза, которую хотим найти в любом месте строки. Функция.match() вернула.строку, в которой нашлось совпадение с шаблоном .*Frank: 'Young Frank'

- search() - аналогично ищет первое совпадение с источнике
- findall() - список всех непересекающихся совпадений
- split() - разбивает источник на совпадения с шаблоном и возвращает список всех фрагментов строки
- sub() - принимает аргумент для замены и заменяет все части источника, совпавшие с шаблоном, на значение этого аргумента

| Шаблон | Совпадения |
| --- | --- |
| \d | Цифровой символ |
| \D | Нецифровой символ |
| \w | Буквенный или цифровой символ или знак подчеркивания |
| \W | Любой символ, кроме буквенного или цифрового символа или знака подчеркивания |
| \s | Пробельный символ |
| \S | Непробельный символ |
| \b | Граница слова |
| \B | Не граница слова |
abc | Буквосочетание abc |
| (expr) | expr |
| `expr1 | expr2` | expr1 или expr2 |
| . | Любой символ, кроме \n |
| ^ | Начало строки источника |
| $ | Конец строки источника |
| prev? | Ноль или одно включение prev |
| prev* | Ноль или больше включений prev, максимальное количество |
| prev*? | Ноль или больше включений prev, минимальное количество |
| prev+ | Одно или больше включений prev, максимальное количество |
| prev+? | Одно или больше включений prev, минимальное количество |
| prev{m} | m последовательных включений prev |
| prev{m,n} | От m до n последовательных включений prev, максимальное количество |
| prev{m,n}? | От m до n последовательных включений prev, минимальное количество |
| [abc] | a, или b, или c (`аналогично a|b|c`) |
| [^abc] | Не (a, или b, или c) |
| prev(?=next) | prev, если за ним следует next |
| prev (?!next) | prev, если за ним не следует next |
| (?<=prev)next | next, если перед ним находится prev |
| (?<!prev)next | next, если перед ним не находится. rev |

Символы ^ и $ называются якорями: с помощью якоря ^ выполняется поиск в начале строки, а с помощью якоря $ — в конце. Сочетание .$ совпадает с любым символом в конце строки. 



