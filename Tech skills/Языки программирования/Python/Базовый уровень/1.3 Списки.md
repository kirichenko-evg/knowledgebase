Удобно хранить объекты в определенном порядке. Можно добавлять новые элементы, перезаписать существующие, удалить. Значения могут повторяться.
Основные моменты:
- создание - [] или list()
- кортежи, строки, множества и словари можно преобразовать в список
- к элементах списка можно обращаться по индексу, с начала или конца строки, с определенным шагом
- используя slice [:] можно извлечь из списка подсписок. При некорректном индексе исключение не генерируется, а используется ближайшей корректный индекс или возращается пустой список
- listname.reverse() перевернет список
- listname.append('test') добавляет элемент в конец
- listname.insert(1, 'test') ставит элемент на заданную позицию
- \* размножает список
- l1.exrend(l2) объединяет списки. Используя append с двумя списками второй добавился бы как элемент первого списка
- l1[1] так можно изменить элемент по смещению
- способ изменить элементы, нужен итерабельный объект
  nums[1:3] = [7, 5, 8, 9] может содержать другое количество элементов
- del l[2] удаляет элемент
- если индекс неизвестен, то элемент можно удалить по значению l.remove('test'). Удалится первый элемент с таким значением
- l.pop() удалит последний элемент и положит его в память. Можно указать аргумент
- используя append(), чтобы добавить новые элементы в конец списка, и функцию pop(), чтобы удалить из конца того же списка, работаем со структурой данных, известной как очередь LIFO (last in, first out — «последним пришел, первым ушел»). Ее чаще называют `стеком`. Вызов pop(0) создает очередь FIFO (first in, first out — «первым пришел, первым ушел»). Это удобный способ собирать данные по мере их поступления и работать либо с самыми старыми (FIFO), либо с самыми новыми (LIFO)
- l.clear() очистит список
- l.index('name') узнать смещение элемента в списке, вернет первое значение
- element in somelist вернет True или False
- l.count('ff') количество элементов в списке
- ','.join(list) объединить список в строку
- len(l) длина
- l.sort() сортирует текущий список. reverse=True по убыванию
- new_l = sorted(l) вернет отсортированную копию списка
- переменная - это ссылка на список. Если нужно скопировать список, то нужно использовать
  * функцию copy(). c = b.copy()
  * list - c = list(b)
  * разделение slice c = b[:]
  * со вложенными списками, словарями используется deepcopy()
    ```python
    import copy
    b = copy.deepcopy(a)
    ```
- списки можно сравнивать. Сравнивается каждый элемент

Параллельное итерирование - создает кортеж из элементов с одинаковым смещением, работа прекратится когда закончится самый короткий список
```python
for elems, test in zip(somel1, somel2)
```

Генератор списков
```python
[i for i in range(1, 6) if условие ]

cells = [(row, col) for row in rows for col in cols]
```

## Кортеж или список?
- кортеж занимает меньше памяти
- элементы кортежа нельзя уничтожить
- кортежи используются в качестве ключей словаря
- именование кортежи служат более простой альтернативой объектам
- в кортежи нельзя вставить данные
- не существует включений кортежей


