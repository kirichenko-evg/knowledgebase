## Массивы (list)

В массиве хранятся объекты как в контейнере. Каждый элемент - отдельный объект.

List - изменяемый объект. Значения внутри него можно изменить следующий образом - обращаясь по индексу. Допустим, если просто умножать значение на значение, без индекса, это работать не будет. Пример с индексом
```python
arr = [1, 2, 3, 4, 5]
for i in range(len(arr)):
    arr[i] *= arr[i]
print(arr)
```

## Простейшие алгоритмы. Копирование массива, поиск элемента в массиве и т.д.
```python
n = int(input())
a = [0] * n
b = [0] * n
for k in range(n):
  a[k] = int(input())
for k in range(n):
  b[k] = a[k]
```
Поэлементное копирование работает и это правильный подход. А вот если сделать `c = a`, то здесь имя `c` только ссылается на имя `a` и объект `a`. В дальнейшем при изменения `a` изменистся и `c`.

Правильный более короткий способ создания нового списка - `c = list(a)`.

### Поиск элемента в массиве
```python
def array_search(A:list, N:int, x:int):
    """ Осуществляет поиск числа x в массиве A от
        0 до N - 1 индекса включительно. Возвращает
        индекс элемента x в массиве A. Или -1 если
        такого элмемента нет. Если в массиве несколько
        одинаковых элементов равных x, то вернется
        индекс первого по счету
    """
    for k in range(N):
        if A[k] == x:
            return k
    return -1

# тестирование пишем сразу, до основной функции
def test_array_search():
    A1 = [1, 2, 3, 4, 5]
    m = array_search(A1, 5, 8)
    if m == -1:
        print('test1 - OK')
    else:
        print('test1 - FAIL')

    A2 = [-1, -2, -3, -4, -5]
    m = array_search(A2, 5, -3)
    if m == 2:
        print('test2 - OK')
    else:
        print('test2 - FAIL')

    
    A3 = [10, 20, 30, 10, 10]
    m = array_search(A3, 5, 10)
    if m == 0:
        print('test3 - OK')
    else:
        print('test3 - FAIL')

test_array_search()
```

### Обращение массива
```python
def invert_array(A:list, N:int):
    """
        Обращение массива (поворот задом-наперед)
        в рамках индексов от 0 до N-1
    """
    for k in range(N//2):
        A[k], A[N - 1 - k] = A[N - 1 - k], A[k]

def test_invert_array():
    A1 = [1, 2, 3, 4, 5]
    invert_array(A1, 5)
    if A1 == [5, 4, 3, 2, 1]:
        print('test1 - OK')
    else:
        print('test1 - FAIL')

    A2 = [0, 0, 0, 0, 0, 0, 0, 10]
    invert_array(A2, 8)
    if A2 == [10, 0, 0, 0, 0, 0, 0, 0]:
        print('test2 - OK')
    else:
        print('test2- FAIL')

test_invert_array()
```

### Циклический сдвиг, решето Эратосфена

Циклический сдвиг может быть ВЛЕВО или ВПРАВО. ВЛЕВО - двигаемся по массиву слева-направо, ВПРАВО - справа-налево.

Влево
```python
tmp = A[0]
for k in range(N-1):
    A[k] = A[k+1]
A[N-1] = tmp
```

Вправо
```python
tmp = A[N-1]
for k in range(N-2, -1, -1):
    A[k+1] = A[k]
A[0] = tmp
```

Решето Эратосфена.

Решето Эратосфена – это алгоритм нахождения простых чисел до заданного натурального числа путем постепенного отсеивания составных чисел. Образно говоря, через решето Эратосфена в процессе его тряски проскакивают составные числа, а простые остаются в решете.

Чтобы понять данный алгоритм, вспомним, что числа являются простыми, если делятся только на единицу и самих себя. Первое простое число - это 2, второе простое число - это 3. Теперь начнем рассуждать:

- Все четные числа, кроме двойки, - составные, т. е. не являются простыми, так как делятся не только на себя и единицу, а также еще на 2.
- Все числа кратные трем, кроме самой тройки, - составные, так как делятся не только на самих себя и единицу, а также еще на 3.
- Число 4 уже выбыло из игры, так как делится на 2.
- Число 5 простое, так как его не делит ни один простой делитель, стоящий до него.
- Если число не делится ни на одно простое число, стоящее до него, значит оно не будет делиться ни на одно сложное число, стоящее до него.

Последний пункт вытекает из того, что сложные числа всегда можно представить как произведение простых. Поэтому если одно сложное число делится на другое сложное, то первое должно делиться на делители второго. Например, 12 делится на 6, делителями которого являются 2 и 3. Число 12 делится и на 2, и на 3.

Алгоритм Эратосфена как раз заключается в последовательной проверке делимости чисел на предстоящие простые числа. Сначала берется первое простое и из ряда натуральных чисел высеиваются все кратные ему. Затем берется следующее простое и отсеиваются все кратные ему и так далее. Краткое объяснение лектора.
```python
A = [True] * N
A[0] = A[1] = False
for k in range(2, N):
    if A[k]:
        for m in range(2*k, N, k):
            A[m] = False
for k in range(N):
    print(k, '-', "простое" if A[k] else "составное")
```
Решение
```python
N = int(input())

# Создается список из значений от 0 до N включительно
primes = [i for i in range(N + 1)]

# Вторым элементом списка является единица, которую
# не считают простым числом. Забиваем ее нулем
primes[1] = 0

# Начинаем с 3-го элемента
i = 2
while i <= N:
    # Если значение текущей ячейки до этого не было обнулено,
    # значит в этой ячейке содержится простое число
    if primes[i] != 0:
        # Первое кратное ему будет в два раза больше
        j = i + i
        while j <= N:
            # и это число составное,
            # поэтому заменяем его нулем
            primes[j] = 0
            # переходим к следующему числу,
            # которое кратно i (оно на i больше)
            j = j + i
    i += 1

# Избавляемся от всех нулей в списке
primes = [i for i in primes if i != 0]
print(primes)
```

