## Массивы (list)

В массиве хранятся объекты как в контейнере. Каждый элемент - отдельный объект.

List - изменяемый объект. Значения внутри него можно изменить следующий образом - обращаясь по индексу. Допустим, если просто умножать значение на значение, без индекса, это работать не будет. Пример с индексом
```python
arr = [1, 2, 3, 4, 5]
for i in range(len(arr)):
    arr[i] *= arr[i]
print(arr)
```

### Простейшие алгоритмы. Копирование массива
```python
n = int(input())
a = [0] * n
b = [0] * n
for k in range(n):
  a[k] = int(input())
for k in range(n):
  b[k] = a[k]
```
Поэлементное копирование работает и это правильный подход. А вот если сделать `c = a`, то здесь имя `c` только ссылается на имя `a` и объект `a`. В дальнейшем при изменения `a` изменистся и `c`.

Правильный более короткий способ создания нового списка - `c = list(a)`.

Поиск элемента в массиве
```python
def array_search(A:list, N:int, x:int):
    """ Осуществляет поиск числа x в массиве A от
        0 до N - 1 индекса включительно. Возвращает
        индекс элемента x в массиве A. Или -1 если
        такого элмемента нет. Если в массиве несколько
        одинаковых элементов равных x, то вернется
        индекс первого по счету
    """
    for k in range(N):
        if A[k] == x:
            return k
    return -1

# тестирование пишем сразу, до основной функции
def test_array_search():
    A1 = [1, 2, 3, 4, 5]
    m = array_search(A1, 5, 8)
    if m == -1:
        print('test1 - OK')
    else:
        print('test1 - FAIL')

    A2 = [-1, -2, -3, -4, -5]
    m = array_search(A2, 5, -3)
    if m == 2:
        print('test2 - OK')
    else:
        print('test2 - FAIL')

    
    A3 = [10, 20, 30, 10, 10]
    m = array_search(A3, 5, 10)
    if m == 0:
        print('test3 - OK')
    else:
        print('test3 - FAIL')

test_array_search()
```

