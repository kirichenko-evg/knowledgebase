Команда `whoami` показывает имя пользователя. 
Абсолютно любой процесс, запускаемый в операционной системе, стартует от имени некоторого пользователя. Соответственно, его возможности по влиянию на файловую систему ограничены правами пользователя, от имени которого процесс запущен.

Команда `ps` (сокращение от process status) выводит отчет о работающих процессах. Информацию о том, какой процесс и под каким пользователем запущен, можно получить из вывода `ps aux`.
Взаимодействие с файловой системой происходит через запуск тех или иных утилит, которые модифицируют, создают или анализируют файловую структуру.

Например, запускаем утилиту touch. Пользователь от своего имени стартует процесс, внутри которого запускается программа touch. Эта программа создает файл и делает пользователя владельцем нового файла.
Модификация существующих файлов не влияет на владельца — для его смены нужно воспользоваться специальной утилитой. В домашней директории пользователя все принадлежит пользователям. Каждый каталог в директории /home — это домашний каталог конкретного пользователя. Поэтому они все имеют разных владельцев, как правило, совпадающих с именем директории.

Имя пользователя в системе должно быть уникальным, но его можно менять. Если посмотреть под капот этой системы, то мы увидим, что имя пользователя связано с идентификатором, называемым UID. Это число, которое и определяет пользователя. Если поменяется имя пользователя, но идентификатор UID останется прежним, то все доступы останутся. Если сменится идентификатор, то фактически сменится и пользователь. Соответственно, новый пользователь потеряет доступы к старому аккаунту.
Посмотреть свой идентификатор можно разными способами. Первый способ — с помощью команды id:
```
id

uid=1002(evg.k) gid=1002(evg.k) groups=1002(evg.k),999(docker)

```
Второй способ связан с просмотром файла, который выступает основным хранилищем пользователей в *nix-системах `cat /etc/passwd`
```
cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
```
Кроме имени и идентификатора, здесь указана командная оболочка по умолчанию и домашняя директория пользователя, которую можно изменить. Запись /usr/sbin/nologin говорит, что пользователь не может входить в систему. Такие пользователи нужны для запуска программ, у которых ограниченные права.

### Группа пользователей
Кроме имени, у пользователей *nix-систем есть связанное с ним понятие — группа. Она создана для группового доступа к разделяемому (общему) ресурсу — например, файлу.
Например, у нас есть группа разработчиков, которые регулярно заходят на сервер. Им нужно дать одинаковые возможности по управлению определенными файлами. Владелец у файла ровно один, поэтому мы не можем решить этот вопрос через смену владельца. Для этого нужно создать группу и привязать ее к самому пользователю.
Группы, ассоциированные с текущим пользователем, показываются в выводе команды id:
```
id

uid=1002(evg.k) gid=1002(evg.k) groups=1002(evg.k),999(docker)
```
Здесь группа evg.k считается основной — такая группа может быть только одна, и именно в нее входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп.

В любой *nix-системе присутствует специальный пользователь — root или суперпользователь. Главная его особенность — это идентификатор со значением 0. Этот пользователь имеет особое значение и может выполнять абсолютно любые действия в системе. Не рекомендуется использовать root на регулярной основе, и ни в коем случае не нужно входить под ним в систему. Суперпользователь — это прямой доступ ко всему и большая дыра в безопасности системы. Кроме того, через него систему очень легко убить: например, удалить не тот файл или испортить важную конфигурацию, после чего вход в систему станет невозможным.
Несмотря на это, root нужен для выполнения некоторых привилегированных действий, которые недоступны обычным пользователям.

### Sudo
В работе с командной строкой нередко возникают ситуации, в которых необходимо повышать привилегии и выполнять команды от имени суперпользователя root. К примеру это
- Установка новых программ
- Навигация по чужим директориям
- Изменение прав доступа
- Изменение содержимого в файлах, не принадлежащих текущему пользователю
- Создание, редактирование и удаление файлов, когда не хватает прав текущего пользователя
- Запуск программ, требующих повышенных привилегий

Ранее пользовались утилитой su (сокращение от substitute user или switch user). Когда-то такой способ был основным, но сейчас он устарел и не рекомендуется к использованию. Основной способ повышать привилегии в современных системах — утилита sudo (substitute user and do — дословно «подменить пользователя и выполнить»). 

Для использования достаточно написать эту команду слева от любой другой и выполнить. По умолчанию она пытается повысить привилегии до суперпользователя.

В зависимости от настроек, утилита sudo попросит пароль для входа или вообще откажется работать, сказав, что у пользователя нет права ее использовать. Как правило, в Ubuntu sudo спрашивает пароль и запоминает его на пять минут. На протяжении этого времени можно использовать sudo, не вводя пароль каждый раз.

Иногда нужно выполнить команду из-под пользователя, отличного от root. Тогда придется добавить флаг -u `sudo -u anotheruser mkdir /tmp/test`. Директория создана от имени пользователя anotheruser.

Если нужно произвести сразу несколько действий от имени другого пользователя, можно запустить новую оболочку внутри текущей. Другими словами, мы стартуем новую сессию `sudo -i`. После работ нужно не забыть переключиться обратно после завершения необходимых манипуляций. Для этого следует ввести `exit`.

Представим, что из-под sudo запустили команду, которая создает файлы и директории. В таком случае владельцем этих файлов становится суперпользователь. Все последующие обращения к этому файлу без sudo начнут выдавать ошибку «У вас нет прав доступа». Причем даже необязательно работать с этими файлами напрямую. Множество программ так или иначе обращаются к файловой системе для чтения конфигурационных и других файлов.

Правильный выход из ситуации в каждом случае свой. В некоторых случаях sudo – это то, что нужно. В других случаях требуется изменить права, а иногда и переустановить какую-нибудь часть системы.

Общее правило может быть таким:
- Все, что лежит в личных директориях пользователя, должно принадлежать этому пользователю
- Все, что находится вне домашней директории пользователя и требует дополнительных прав, скорее должно запускаться с sudo, но бывают и исключения




