Команда `whoami` показывает имя пользователя. 
Абсолютно любой процесс, запускаемый в операционной системе, стартует от имени некоторого пользователя. Соответственно, его возможности по влиянию на файловую систему ограничены правами пользователя, от имени которого процесс запущен.

Команда `ps` (сокращение от process status) выводит отчет о работающих процессах. Информацию о том, какой процесс и под каким пользователем запущен, можно получить из вывода `ps aux`.
Взаимодействие с файловой системой происходит через запуск тех или иных утилит, которые модифицируют, создают или анализируют файловую структуру.

Например, запускаем утилиту touch. Пользователь от своего имени стартует процесс, внутри которого запускается программа touch. Эта программа создает файл и делает пользователя владельцем нового файла.
Модификация существующих файлов не влияет на владельца — для его смены нужно воспользоваться специальной утилитой. В домашней директории пользователя все принадлежит пользователям. Каждый каталог в директории /home — это домашний каталог конкретного пользователя. Поэтому они все имеют разных владельцев, как правило, совпадающих с именем директории.

Имя пользователя в системе должно быть уникальным, но его можно менять. Если посмотреть под капот этой системы, то мы увидим, что имя пользователя связано с идентификатором, называемым UID. Это число, которое и определяет пользователя. Если поменяется имя пользователя, но идентификатор UID останется прежним, то все доступы останутся. Если сменится идентификатор, то фактически сменится и пользователь. Соответственно, новый пользователь потеряет доступы к старому аккаунту.
Посмотреть свой идентификатор можно разными способами. Первый способ — с помощью команды id:
```
id

uid=1002(evg.k) gid=1002(evg.k) groups=1002(evg.k),999(docker)

```
Второй способ связан с просмотром файла, который выступает основным хранилищем пользователей в *nix-системах `cat /etc/passwd`
```
cat /etc/passwd

root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
```
Кроме имени и идентификатора, здесь указана командная оболочка по умолчанию и домашняя директория пользователя, которую можно изменить. Запись /usr/sbin/nologin говорит, что пользователь не может входить в систему. Такие пользователи нужны для запуска программ, у которых ограниченные права.

### Группа пользователей
Кроме имени, у пользователей *nix-систем есть связанное с ним понятие — группа. Она создана для группового доступа к разделяемому (общему) ресурсу — например, файлу.
Например, у нас есть группа разработчиков, которые регулярно заходят на сервер. Им нужно дать одинаковые возможности по управлению определенными файлами. Владелец у файла ровно один, поэтому мы не можем решить этот вопрос через смену владельца. Для этого нужно создать группу и привязать ее к самому пользователю.
Группы, ассоциированные с текущим пользователем, показываются в выводе команды id:
```
id

uid=1002(evg.k) gid=1002(evg.k) groups=1002(evg.k),999(docker)
```
Здесь группа evg.k считается основной — такая группа может быть только одна, и именно в нее входят любые создаваемые файлы от имени текущего пользователя. Кроме основной, пользователь может входить в произвольное число дополнительных групп.
В любой *nix-системе присутствует специальный пользователь — root или суперпользователь. Главная его особенность — это идентификатор со значением 0. Этот пользователь имеет особое значение и может выполнять абсолютно любые действия в системе. Не рекомендуется использовать root на регулярной основе, и ни в коем случае не нужно входить под ним в систему. Суперпользователь — это прямой доступ ко всему и большая дыра в безопасности системы. Кроме того, через него систему очень легко убить: например, удалить не тот файл или испортить важную конфигурацию, после чего вход в систему станет невозможным.
Несмотря на это, root нужен для выполнения некоторых привилегированных действий, которые недоступны обычным пользователям.

