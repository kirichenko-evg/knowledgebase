## Потоки
Печать на экран с точки зрения ОС. При старте любой программы операционная система связывает с печатью три потока:
- STDIN (Standard Input)
- STDOUT (Standard Output)
- STDERR (Standard Error)

Для языка программирования эти потоки выглядят как файлы, и взаимодействие с ними происходит как с файлами. 

### STDOUT
STDOUT - отвечает за вывод на экран. Во время каждой печати на экран в программе на любом языке происходит следующие два шага:
- функция печати записывает данные в поток STDOUT с помощью функции write
- операционная система решает, куда вывести результат. По умолчанию вывод происходит на экран терминала

Для понимания этого вопроса, нужно подробно изучить устройство операционных систем, в частности подсистемы, отвечающей за процессы и файловую систему.
В двух словах, языки программирования не взаимодействуют с монитором и железом в целом. За взаимодействие с железом целиком и полностью отвечает операционная система. Программы могут только лишь попросить операционную систему выполнить ту или иную задачу.
При таком разделении реализация языков программирования сильно упрощается. Достаточно знать про существование STDOUT и уметь писать в этот поток, а дальше все сделает операционная система.
Именно благодаря такому разделению и потокам, можно написать программу на одном компьютере и без проблем запустить ее на другом компьютере с другой конфигурацией и монитором.
Операционные системы позволяют подменять потоки при старте системы, что открывает интересные возможности.
Например, вывод любой команды в bash можно не выводить на экран, а записать в файл:
```
ls -la > output
```
Запустив эту команду, на экране не отобразится ничего нового. Зато в текущей директории появится файл output:
```
cat output

total 44
drwxr-xr-x 5 kirill.m kirill.m 4096 Aug 29 09:39 .
drwxr-xr-x 8 root     root     4096 Apr 26 10:38 ..
-rw------- 1 kirill.m kirill.m 1822 Aug 29 08:45 .bash_history
-rw-r--r-- 1 kirill.m kirill.m  220 Aug 31  2015 .bash_logout
-rw-r--r-- 1 kirill.m kirill.m 3771 Aug 31  2015 .bashrc
drwx------ 2 kirill.m kirill.m 4096 Mar 30 18:10 .cache
```
Операция выше называется `перенаправление потоков`.
Символ > означает, что нужно взять вывод из команды слева и отправить его в файл, указанный справа. Этот символ > всегда перезаписывает файл.
Такое перенаправление работает с абсолютно любой командой, которая выводит результаты своей работы в консоль:
```
grep alias .bash_profile > result
cat result

alias fixssh='eval $(tmux showenv -s SSH_AUTH_SOCK)'

```
Если нужно не перезаписывать, а добавлять, то нужно написать >>.
Для экспериментов с выводом удобно использовать встроенную команду echo. Она принимает на вход строчку и выдает ее в STDOUT, который уже можно перенаправлять:
```
# > Заменяет содержимое файла
echo 'hi' > result # Вывод команды echo направляем в файл result
cat result # С помощью команды cat читаем файл result

hi # Содержимое файла result в окне терминала

echo 'hello' > result # Вывод команды echo заменяет содержимое файла result
cat result # С помощью команды cat читаем файл result

hello # Содержимое файла result в окне терминала

# >> Добавляет содержимое в конец файла
echo 'hello' >> result # Вывод команды echo добавляем в конец файла result
cat result # С помощью команды cat читаем файл result

# Так выглядит содержимое файл result в окне терминала:
hello
hello
```

### STDIN — стандартный ввод

STDIN работает в обратную сторону: через него программа может получать данные на вход.
В *nix-системах встроена утилита wc (сокращение от word count). Она умеет считать количество слов, строк или символов в файле. Когда мы говорим о файле, то в *nix-системах это почти всегда означает, что данные можно передать и в стандартный поток ввода. Cтрелка в примере меняет свое направление в другую сторону и содержимое файла отправляется в поток STDIN запускаемой программы wc.
```
# Флаг l (буква l, а не цифра 1) указывает, что надо считать количество строк
wc -l < result # Содержимое файла result отправляем в стандартный ввод команды wc

2
```
Теперь объединим перенаправление ввода и вывода:
```
wc -l < result > output # Содержимое файла result отправляем в стандартный ввод команды wc, а вывод направляем в файл output
cat output # С помощью команды cat читаем файл output

2
```

### STDERR

Поток STDERR позволяет отделить нормальный вывод программы от возникающих ошибок.
Как и STDOUT, он по умолчанию выводит информацию на экран. Такой подход удобен при ведении логов, для реагирования и отладки. Перенаправление вывода в файл перенаправляет только STDOUT. Убедиться в этом очень просто. Если попробовать отобразить содержимое несуществующей директории, то команда ls выдаст ошибку. Перенаправление есть, но сообщение выведется на экран. Это произошло именно по той причине, что STDERR остался привязан к экрану, а внутри файла output — пустота. Решить эту задачу можно несколькими способами.

### Перенаправление STDERR в STDOUT
В unix-системах за каждым потоком закреплен определенный номер, который называется файловым дескриптором. С помощью него можно получить доступ к потокам ввода и вывода.
Существуют следующие стандартные потоки ввода и вывода:
- STDIN — 0
- STDOUT — 1
- STDERR — 2

Первый способ — перенаправить STDERR в STDOUT или отправить оба потока в файл. Часто стандартный поток ошибок объединяют со стандартным потоком вывода, чтобы можно было обрабатывать ошибки и результат выполнения вместе. В примере есть символ & после символа перенаправления >. По правилам синтаксиса символ & нужно ставить, чтобы указать поток, в который осуществляется перенаправление.
```
# Сначала STDOUT перенаправляется в файл output, затем STDERR перенаправляется в STDOUT, запись в файл продолжается
ls lala > output 2>&1
cat output # С помощью команды cat читаем содержимое файла output

ls: cannot access 'lala': No such file or directory # Содержимое файла output в окне терминала

```
В примере ниже 2>&1 написано перед > output. Это не будет работать, потому что когда интерпретатор прочитает 2>&1, он еще не будет знать, куда перенаправлен стандартный поток вывода. Поэтому потоки ошибок и вывода не будут объединены:
```
ls lala 2>&1 > output

ls: cannot access 'lala': No such file or directory # Вывод в окне терминала

```
Перенаправление потока STDERR бывает полезно само по себе, без вывода в файл:
```
#  Так можно сразу перенаправить STDERR в файл
cd lala 2> output
cat output

-bash: cd: lala: No such file or directory
```

### Перенаправление обоих потоков в файл
Так удобно проводить отладку и определять, почему вообще возникла та или иная ошибка:
```
# Оба потока (STDERR и STDOUT) перенаправляются в файл
cd lala &> output
cat output

-bash: cd: lala: No such file or directory
```
