Файловая структура:
- представляет собой дерево
- в узлах этого дерева находятся директории (каталоги) — файлы специального типа
- в листьях дерева расположены файлы

- имена регистрозависимые
- в Windows файловая структура представлена несколькими деревьями, так как каждая структура находится на своем диске. В *nix-системах есть единственное дерево с корнем в `/`. Все устройства, физические и логические диски находятся внутри этого дерева в виде директорий и файлов
- информация о любом файле или директории доступна по команде `stat`.
- на пользовательском уровне директория все же отличается от файла и имеет собственные команды для создания, удаления и модификаци
- FHS — базовый стандартизированный набор каталогов [FHS на вики](https://ru.wikipedia.org/wiki/FHS). За каждым закреплена какая-то особая роль, например:
    * каталог /etc содержит конфигурацию программ в обычных текстовых файлах. В *nix-системах нет реестра, вся конфигурация лежит в обычных файлах
    * каталог /home содержит домашние директории пользователей системы, за исключением суперпользователя root, домашний каталог которого обычно находится по адресу /root
- в *nix-системах развитая система прав, завязанная на пользователей и группы. Такие ограничения можно увидеть в выводе команды ls -l
- в *nix-системах отсутствует понятие «расширение файла». Здесь точка считается полноправной частью имени файла. При этом файлы почти всегда именуются так же, как и в Windows
- в *nix-системах файл считается скрытым, если его имя начинается с точки. Чтобы скрыть файл, ничего не нужно делать в настройках — достаточно просто добавить точку в начале
- при выводе ls -a
    * директория обозначенная точкой (.) — это текущая директория
    * директория обозначенные двумя точками (..) — это директория верхнего уровня
   
- Hard Link — дополнительное имя для уже существующего файла
- Symbolic link — символическая ссылка. Данный файл похож на ярлык в Windows. Если удалить основной файл, то символическая ссылка будет вести в никуда
- Socket — специальный файл, через который происходит взаимодействие между разными процессами операционной системы


## Чтение файлов
- cat - команда для чтения файлов. Ожидает аргументы — пути до файлов, которые надо читать. Подходит для небольших файлов
- head показывает первые 10 строк
- tail — последние 10 строк файла. Опция -n `tail -n 2 .bashrc` для head и tail задает желаемое количество строк для чтения

Некоторые файлы наполняются очень интенсивно. Например, быстро наполняются логи. В Linux логи лежат в каталоге /var/log. Туда пишет сам Linux, и большая часть установленных программ. Основной файл логов Linux называется syslog. Просмотреть логи поможет tail, запущенный в особом режиме — с флагом -f. Допупустим, нужно изучить события, которые происходят часто. Команда `tail -f path/to/file` не просто выводит последние строчки файла, но и ждет появления новых. Как только файл дописывается, tail сразу выводит на экран добавленные строки.

### Пейджеры
Пейджеры - категория программ для просмотра содержимого файла. Пейджер похож на текстовый редактор, открытый только в режиме чтения. Самый распространенный пейджер называется less. Он позволяет производить поиск и перемещаться по файлу вперед и назад. Особенность пейджеров состоит в том, что они одинаково хорошо работают с файлами любых размеров. Пейджер не пытается загрузить в память весь файл до его отображения. Он грузит только ту часть, которая помещается на экран и при перемещении подгружает остальное. 
Команды:
- выход — q
- вперед на страницу — f
- назад на страницу — b
- поиск введенного текста — вводим /, печатаем текст и нажимаем Enter
- переход к следующему совпадению — n
- переход к предыдущему совпадению — N


## GREP
Grep - global regular expression print. Утилита для поиска определенного текста по файлу или файлам.
```
man grep

SYNOPSIS
       grep [OPTIONS] PATTERN [FILE...]
       grep [OPTIONS] [-e PATTERN]...  [-f FILE]...  [FILE...]
```
- PATTERN — это то, что мы хотим найти. Конкретная строка или определенный шаблон с регулярными выражениями
- FILE — путь к файлу
```
# Поиск всех строк в файле .bashrc, в которых встречается слово aliases
grep aliases .bashrc

# enable color support of ls and also add handy aliases
# some more ls aliases
# ~/.bash_aliases, instead of adding them here directly.
if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
```
Найденные строки выводятся на экран в том же порядке, в котором они встречаются в исходном файле. В некоторых ситуациях нужно увидеть не только саму строку, но и текст вокруг нее. Количество выводимых соседних строк регулируется тремя опциями:
- количество отображаемых строк до искомой строки — -B или --before-context
- количество отображаемых строк после искомой — -A или --after-context
- количество отображаемых строк до и после искомой строки — -C или --context
Пример использования -C со значением 1. Это значит, что для каждой найденной строки будет выведена одна строка выше и одна строка ниже:
```
grep -C 1 aliases .bashrc

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
--

# some more ls aliases
alias ll='ls -alF'
--
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi
```
Иногда мы не знаем, в каком файле находится то, что мы ищем. При этом мы можем знать директорию, в которой лежит этот файл. В такой ситуации нужно сделать два изменения:
1. Добавить опцию -r — она указывает, что надо искать внутри директории. Поиск идет рекурсивно, то есть с включением всех поддиректорий
2. Указать путь до директории, а не файла
Применяем утилиту grep с опцией -r. При таком поиске в выводе указывается файл, в котором была найдена строка. Если добавить опцию n, то дополнительно отобразится номер строки:
```
grep -rn bashrc .

./.profile:13:    # include .bashrc if it exists
./.profile:14:    if [ -f "$HOME/.bashrc" ]; then
./.profile:15:  . "$HOME/.bashrc"
./.bash_history:56:du -sh .bashrc
./.bash_history:57:stat .bashrc
./.bash_history:58:stat -h .bashrc
./.bash_history:60:file .bashrc
./.bash_history:61:stat .bashrc
./.bash_history:63:cat .bashrc
./.bashrc:1:# ~/.bashrc: executed by bash(1) for non-login shells.
./.bashrc:109:# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
./.bashrc:110:# sources /etc/bash.bashrc).
```


## Редактирование файлов
- `nano .bashrc` - открыть nano для редактирования. Это обычный редактор, который подходит для несложных изменений в файлах, но им неудобно пользоваться для работы над проектами с множеством файлов и сложным кодом
- `vim .bashrc` - открыть vim. В нем есть режимы. В обычных редакторах мы открываем файл и сразу можем приступать к редактированию. Vim запускается в режиме COMMAND — это режим команд, при котором нажатие на любую клавишу воспринимается как сигнал к какому-то действию.
Обычное редактирование текста выполняется в режиме ввода — INSERT. Попасть в него можно с помощью клавиши i. Для выхода в режим команд достаточно нажать Esc или комбинацию Ctrl + [.

Всего у Vim есть четыре основных режима работы:
- командный режим — это режим по умолчанию. В нем можно перемещаться по файлу, вносить изменения с помощью комбинаций клавиш, удалять и искать текст
- режим вставки — это режим ввода текста с клавиатуры. Здесь все работает так, как в обычных редакторах
- визуальный режим — выделение произвольных участков текста
- режим командной строки — собственная командная строка для редактора текста, из которой можно выполнять множество разнообразных команд

Выход из Vim:
- перейти в командный режим. На всякий случай нажать Esc или комбинацию Ctrl + [
- затем набрать : (символ "двоеточие") — команда переведет в режим командной строки
- в конце ввести `q!` и нажмите Enter. Это выход из Vim без сохранения изменений. Если набрать `:wq`, то перед выходом сохранятся все изменения. Если нужно просто сохраниться без выхода, то `:w`.
